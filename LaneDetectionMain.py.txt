import cv2
import numpy as np

scale_window = 0.30  # procente
final_sclale = 0.50
cam = cv2.VideoCapture("Lane Detection Test Video-01.mp4")
y_final = int(cam.get(cv2.CAP_PROP_FRAME_HEIGHT) * final_sclale)
x_final = int(cam.get(cv2.CAP_PROP_FRAME_WIDTH) * final_sclale)
y = int(cam.get(cv2.CAP_PROP_FRAME_HEIGHT) * scale_window)
x = int(cam.get(cv2.CAP_PROP_FRAME_WIDTH) * scale_window)
half_x = x // 2
########################################################################################################################
# trapez
dimensiune_baza_mica = 0.27  # procente adaus      #0.20
dimensiune_baza_mare_right = 0.20  # procente micsorare  #0.20
dimensiune_baza_mare_left = 0.20  # procente micsorare  #0.20
inaltime_baza_mica = 0.23  # fata de Y             #0.231
inaltime_baza_mare = 0.00  # fata de Y             #0.00
# blur numar impar
blur = 9  # 7 sau 9 de preferat
# sobel efect
forta_effect_sobel = 1  # procente
pixel_threshold = 60  # pentru 60 merge ok
# procentaj marcaje
banda_neagra_laterala = 0.1  # procente
banda_neagra_jos = 0.03  # procente
banda_omitere_mijloc = 0.03  # procente
# linii
grosime_lini = 20  # int te rog
fragmentare = 20  # pentru 20 merge ok
add_shift = 20  # specific dreapta unde natural este jumatate dar aparent mai are nevoie

limita_linie = -0.10  # procente cu cat mai mic cu atat mai mare se face regiunea de acceptate

good_color = (50, 250, 50)  # verde
bad_color = (50, 50, 250)  # rosu
max_color = (250, 50, 50)  # albastru
########################################################################################################################
limita_dreapta = int(half_x * (1 - limita_linie))
limita_stanga = int(half_x * limita_linie)

sobel_vertical = np.float32([[-1, -2, -1], [0, 0, 0], [+1, +2, +1]])
sobel_orizontal = np.transpose(sobel_vertical)

my_widow_size = (x, y)
my_widow_size_inv = (y, x)

# anti elicopter efect, stabilizeaza umpic linia
# creaza efect de tranzie intre 2 stari stabile
deplasare_maxima: int = half_x // fragmentare
shift = x * banda_omitere_mijloc
shift = half_x + int(shift)

# Tot ce tine de trapez
upper_left = (int(x - x * ((1 - dimensiune_baza_mica) / 2)), int(y * (1 - inaltime_baza_mica)))
upper_right = (int(x - x * ((1 - dimensiune_baza_mica) / 2 + dimensiune_baza_mica)), int(y * (1 - inaltime_baza_mica)))
lower_left = (int(x * (1 - (dimensiune_baza_mare_left / 2))), int(y * (1 - inaltime_baza_mare)))
lower_right = (int(x * (dimensiune_baza_mare_right / 2)), int(y * (1 - inaltime_baza_mare)))

forma_trapez = np.float32([upper_right, lower_right, lower_left, upper_left])
forma_camera = np.float32([(0, 0), (0, y), (x, y), (x, 0)])
stretch = cv2.getPerspectiveTransform(forma_trapez, forma_camera)
restore_stretch = cv2.getPerspectiveTransform(forma_camera, forma_trapez)

trapez = [upper_right, upper_left, lower_left, lower_right]
puncte_trapez = np.array(trapez)

left_top = 0, 0
left_bot = 0, 0
right_top = 0, 0
right_bot = 0, 0

left_bot_linie = (0, 0)
left_top_linie = (0, 0)
right_bot_linie = (0, 0)
right_top_linie = (0, 0)
right_bot_linie_shifted = (0, 0)
right_top_linie_shifted = (0, 0)

color_left = (255, 255, 255)
color_right = (255, 255, 255)


def Linie_management(bot, top, last_bot, last_top, string):
    if last_bot == 0:
        if bot < limita_stanga:
            if top < limita_stanga:
                return limita_stanga, limita_stanga, bad_color
            if top > limita_dreapta:
                return limita_stanga, limita_dreapta, bad_color
        if bot < limita_dreapta:
            if top < limita_stanga:
                return limita_dreapta, limita_stanga, bad_color
            if top > limita_dreapta:
                return limita_dreapta, limita_dreapta, bad_color
        return bot, top, good_color
    if bot < limita_stanga or top < limita_stanga or bot > limita_dreapta or top > limita_dreapta:
        print("Out of bound! keep last " + string)
        return last_bot, last_top, bad_color
        # Gestionarea în caz de limită
    color = good_color
    lim_bot_min = (last_bot - deplasare_maxima)
    lim_bot_max = (last_bot + deplasare_maxima)
    lim_top_min = (last_top - deplasare_maxima)
    lim_top_max = (last_top + deplasare_maxima)

    bot_to_return = bot
    top_to_return = top

    if bot < lim_bot_min:
        bot_to_return = lim_bot_min
        color = max_color
    if bot > lim_bot_max:
        bot_to_return = lim_bot_max
        color = max_color
    if top < lim_top_min:
        top_to_return = lim_top_min
        color = max_color
    if top > lim_top_max:
        top_to_return = lim_top_max
        color = max_color

    return bot_to_return, top_to_return, color


########################################################################################################################
while True:
    ret, frame = cam.read()
    if ret is False:
        break
    frame = cv2.resize(frame, my_widow_size)

    frame_gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)

    frame_masca_trapez = np.zeros(my_widow_size_inv, dtype=np.uint8)
    frame_masca_trapez = cv2.fillConvexPoly(frame_masca_trapez, puncte_trapez, 255)

    frame_trapez = frame_masca_trapez * frame_gray * 255

    frame_stretch = cv2.warpPerspective(frame_trapez, stretch, my_widow_size)

    frame_blur = cv2.blur(frame_stretch, (blur, blur), 0)
    frame_blur_float32 = np.float32(frame_blur)

    frame_sobel_vertical = cv2.filter2D(frame_blur_float32, -1, sobel_vertical)
    frame_sobel_orizontal = cv2.filter2D(frame_blur_float32, -1, sobel_orizontal)

    # frame_sobel =frame_sobel_orizontal * frame_sobel_vertical / 2
    frame_sobel = np.sqrt(frame_sobel_orizontal ** 2 + frame_sobel_vertical ** 2)
    frame_sobel = frame_sobel.astype(np.uint8)
    frame_sobel = cv2.resize(frame_sobel, my_widow_size)

    _, frame_binar = cv2.threshold(frame_sobel, pixel_threshold, 255, cv2.THRESH_BINARY)

    frame_bari_negre = frame_binar.copy()
    frame_bari_negre[:, :(int(x * banda_neagra_laterala))] = 0
    frame_bari_negre[:, -(int(x * banda_neagra_laterala)):] = 0
    frame_bari_negre[-(int(y * banda_neagra_jos)):, :] = 0

    pixeli_albi = np.argwhere(frame_bari_negre[:, :int(half_x - x * banda_omitere_mijloc)] > 1)
    y_left_raw = pixeli_albi[:, 0]
    x_left_raw = pixeli_albi[:, 1]

    pixeli_albi = np.argwhere(frame_bari_negre[:, -int(half_x - x * banda_omitere_mijloc):] > 1)
    y_right_raw = pixeli_albi[:, 0]
    x_right_raw = pixeli_albi[:, 1]
    # print( x_right_raw)

    frame_lini = frame_bari_negre.copy()
    if len(x_left_raw) > 0:
        b_left, a_left = np.polynomial.polynomial.polyfit(x_left_raw, y_left_raw, deg=1)

        y_left_linie = [0, y]
        x_left_linie = (y_left_linie - b_left) // a_left

        x_left_bot, x_left_top, color_left = Linie_management(x_left_linie[0], x_left_linie[1], left_bot_linie[0],
                                                              left_top_linie[0], "stanga")

        left_bot_linie = (int(x_left_bot), 0)
        left_top_linie = (int(x_left_top), y)

        frame_lini = cv2.line(frame_lini, left_bot_linie, left_top_linie, 255, 10)

    if len(x_right_raw) > 0:
        b_right, a_right = np.polynomial.polynomial.polyfit(x_right_raw, y_right_raw, deg=1)

        y_right_linie = [0, y]
        x_right_linie = (y_right_linie - b_right) // a_right

        x_right_bot, x_right_top, color_right = Linie_management(x_right_linie[0], x_right_linie[1], right_bot_linie[0],
                                                                 right_top_linie[0], "dreapta")

        right_bot_linie = (int(x_right_bot), 0)
        right_top_linie = (int(x_right_top), y)
        right_bot_linie_shifted = (int(x_right_bot) + shift, 0)
        right_top_linie_shifted = (int(x_right_top) + shift, y)
        frame_lini = cv2.line(frame_lini, right_bot_linie_shifted, right_top_linie_shifted, 255, 10)

    frame_lini_only_right = np.zeros(my_widow_size_inv, dtype=np.uint8)
    frame_lini_only_right = cv2.cvtColor(frame_lini_only_right, cv2.COLOR_GRAY2RGB)

    frame_lini_only_right = cv2.line(frame_lini_only_right, right_bot_linie_shifted, right_top_linie_shifted,
                                     color_right, grosime_lini)
    frame_lini_only_right = cv2.warpPerspective(frame_lini_only_right, restore_stretch, my_widow_size)

    frame_lini_only_left = np.zeros(my_widow_size_inv, dtype=np.uint8)
    frame_lini_only_left = cv2.cvtColor(frame_lini_only_left, cv2.COLOR_GRAY2RGB)

    frame_lini_only_left = cv2.line(frame_lini_only_left, left_bot_linie, left_top_linie,
                                    color_left, grosime_lini)
    frame_lini_only_left = cv2.warpPerspective(frame_lini_only_left, restore_stretch, my_widow_size)

    frame_final = frame.copy()
    frame_lini_color = frame_lini_only_left * 255 + frame_lini_only_right * 255
    frame_final = frame_final + frame_lini_color
    frame_final = cv2.resize(frame_final, (x_final, y_final))

    cv2.imshow('Original', frame)
    cv2.imshow('Gri', frame_gray)
    cv2.imshow('Masca trapez', frame_masca_trapez)
    cv2.imshow('Trapez', frame_trapez)
    cv2.imshow('Bird view', frame_stretch)
    cv2.imshow('Blur', frame_blur)
    cv2.imshow('Filtru Sobel', frame_sobel)
    cv2.imshow('Filtru binar', frame_binar)
    cv2.imshow('Bari negre', frame_bari_negre)
    cv2.imshow('Lini bird view', frame_lini)
    cv2.imshow('Lini normal', frame_lini_color)
    cv2.imshow('Final', frame_final)
    if cv2.waitKey(15) & 0xFF == ord('q'):
        break

cam.release()
cv2.destroyAllWindows()
